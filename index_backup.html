<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ethical Deer Hunting 3D</title>
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <div id="crosshair"></div>
    
    <div id="scope-overlay">
        <div class="crosshair-line vertical" id="line-top"></div>
        <div class="crosshair-line vertical" id="line-bottom"></div>
        <div class="crosshair-line horizontal" id="line-left"></div>
        <div class="crosshair-line horizontal" id="line-right"></div>
        <div id="scope-center"></div>
    </div>

    <!-- HUD Elements -->
    <div id="compass-container" class="hud initially-hidden">
        <span id="compass-value">N</span>
    </div>

    <div class="hud-container top-left initially-hidden">
        <div id="score-container" class="hud">
            Score: <span id="score-value">0</span>
        </div>
        <div id="clock-container" class="hud">
            Time: <span id="clock-value">08:00</span>
        </div>
        <div id="scoring-guide-container" class="hud collapsible-container initially-hidden">
            <div id="scoring-guide-header" class="collapsible-header">
                <span>Scoring Guide</span>
                <span id="scoring-guide-toggle" class="collapsible-toggle">[+]</span>
            </div>
            <div id="scoring-guide-body" class="collapsible-body collapsed initially-hidden">
                <b>Vitals Shot:</b> +100 Base<br>
                <b>Head Shot:</b> +25 Base<br>
                <b>Recovery Shot:</b> +20 Base<br>
                <b>Close Shot Bonus:</b> +(100-Yards)<br>
                <b>Successful Tag:</b> +25 Points<br>
                <b>Moving Target Hit:</b> -50 Points<br>
                <b>Wounding Shot:</b> -25 Points<br>
                <b>Missed Shot:</b> -20 Points<br>
                <b>Illegal Shot:</b> -100 Points<br>
                <small>*Distance penalty on fatal shots.</small>
            </div>
        </div>
    </div>

    <div class="hud-container top-right initially-hidden">
        <div id="instructions-container" class="hud collapsible-container">
            <div id="instructions-header" class="collapsible-header">
                <span>Instructions</span>
                <span id="instructions-toggle" class="collapsible-toggle">[-]</span>
            </div>
            <div id="instructions-body" class="collapsible-body initially-hidden">
                <b>W, A, S, D:</b> Move<br>
                <b>Mouse:</b> Look<br>
                <b>Left Click:</b> Shoot<br>
                <b>Right Click:</b> Aim Scope<br>
                <b>E:</b> Tag Deer<br>
                <small>Legal Hours: 5:30 - 19:30</small>
            </div>
        </div>
         <button id="journal-button" class="hud initially-hidden" style="margin-top:10px; width: 240px; cursor: pointer;">View Journal</button>
         <button id="map-button" class="hud initially-hidden" style="margin-top:10px; width: 240px; cursor: pointer;">View Map</button>
    </div>
    
    <div id="message" class="initially-hidden"></div>
    <div id="interaction-prompt" class="initially-hidden"></div>

    <!-- Modals -->
    <div id="report-modal-backdrop" class="modal-backdrop">
        <div id="report-modal" class="modal">
            <h2 id="report-title">Daily Journal</h2>
            <div id="report-content">...</div>
            <div class="button-group">
                <button id="close-report-button">Close</button>
            </div>
        </div>
    </div>
    
    <div id="map-modal-backdrop" class="modal-backdrop">
        <div id="map-modal" class="modal">
            <h2>Area Map</h2>
            <div id="map-container">
                 <canvas id="map-canvas"></canvas>
            </div>
            <button id="close-map-button">Close</button>
        </div>
    </div>

    <div id="main-menu">
        <h1>Fairchase</h1>
        <div class="menu-item">
            <label for="world-select">Select World:</label>
            <select id="world-select">
                <!-- Options will be populated by JavaScript -->
            </select>
        </div>
        
        <!-- TEMPORARY: Testing deer spawn modes (remove before production) -->
        <div class="menu-item" style="border: 2px dashed #ff6b6b; padding: 10px; margin: 10px 0; background-color: rgba(255, 107, 107, 0.1);">
            <label style="color: #ff6b6b; font-weight: bold; font-size: 12px;">ðŸ§ª TESTING MODE (TEMPORARY)</label>
            <div style="margin-top: 8px;">
                <label for="deer-spawn-mode">Deer Spawn:</label>
                <div style="margin-top: 5px;">
                    <input type="radio" id="spawn-random" name="deer-spawn-mode" value="random" checked>
                    <label for="spawn-random" style="margin-left: 5px; margin-right: 15px;">Randomized spawning</label>
                    
                    <input type="radio" id="spawn-front" name="deer-spawn-mode" value="front">
                    <label for="spawn-front" style="margin-left: 5px;">Spawn in front of me</label>
                </div>
            </div>
            <div style="margin-top: 12px;">
                <label for="deer-behavior-mode">Deer Behavior:</label>
                <div style="margin-top: 5px;">
                    <input type="radio" id="behavior-normal" name="deer-behavior-mode" value="normal" checked>
                    <label for="behavior-normal" style="margin-left: 5px; margin-right: 15px;">Normal (will flee)</label>
                    
                    <input type="radio" id="behavior-no-flee" name="deer-behavior-mode" value="no-flee">
                    <label for="behavior-no-flee" style="margin-left: 5px;">Debug (will not flee)</label>
                </div>
            </div>
        </div>
        
        <button id="start-button" class="menu-item">Start Game</button>
    </div>

    <div id="sleep-overlay">
        <div id="sleep-timer"></div>
    </div>


    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.183.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.183.0/examples/jsm/",
                "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.183.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>

    <script type="module" src="js/main.js"></script>
    <!--
        // Game variables
        let scene, camera, renderer, player, deer, ground;
        let waterBodies = [];
        let drinkingSpots = [];
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let score = 0;
        let raycaster = new THREE.Raycaster();
        let gunshot;
        let legs = [];
        let trees = [];
        let tracks = [];
        let bloodDrops = []; 
        let lastTrackPosition = new THREE.Vector3();
        let lastBloodDropPosition = new THREE.Vector3();
        let isScoped = false;
        let mouseSensitivity = 0.002;
        let canTag = false;
        let killInfo = null;
        let huntLog = null;
        let dailyKillInfo = null;
        let distanceTraveled = 0;
        let lastPlayerPosition = new THREE.Vector3();
        let ambientLight;
        let gameTime = 8; 
        let journalEntries = [];
        let isSleeping = false;

        // Deer AI variables
        let deerState = 'WANDERING'; 
        let wanderTarget = new THREE.Vector3();
        let stateTimer = 0;
        let timeSinceLastDrink = 0;
        let neck;

        // Map variables
        let mapRenderer;

        // World constants
        const worldSize = 1000;

        // DOM Elements
        const scoreValueElement = document.getElementById('score-value');
        const clockValueElement = document.getElementById('clock-value');
        const compassValueElement = document.getElementById('compass-value');
        const messageElement = document.getElementById('message');
        const crosshairElement = document.getElementById('crosshair');
        const scopeOverlayElement = document.getElementById('scope-overlay');
        const interactionPromptElement = document.getElementById('interaction-prompt');
        const reportModalBackdrop = document.getElementById('report-modal-backdrop');
        const reportModal = document.getElementById('report-modal');
        const closeReportButton = document.getElementById('close-report-button');
        const reportContent = document.getElementById('report-content');
        const journalButton = document.getElementById('journal-button');
        const reportTitle = document.getElementById('report-title');
        const mapButton = document.getElementById('map-button');
        const mapModalBackdrop = document.getElementById('map-modal-backdrop');
        const closeMapButton = document.getElementById('close-map-button');
        const mapCanvas = document.getElementById('map-canvas');
        const sleepOverlay = document.getElementById('sleep-overlay');
        const sleepTimerElement = document.getElementById('sleep-timer');


        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x6ca0dc);
            scene.fog = new THREE.Fog(0x6ca0dc, 150, 400); 
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            scene.add(directionalLight);

            createHills();
            createWater();
            findDrinkingSpots();
            player = new THREE.Group();
            player.add(camera);
            scene.add(player);
            player.position.set(0, getHeightAt(0, 10) + 1.7, 10);
            lastPlayerPosition.copy(player.position);
            gunshot = new Tone.MembraneSynth().toDestination();
            createTrees();
            createDeer();
            initMap();
            
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('contextmenu', (event) => event.preventDefault()); 
            window.addEventListener('resize', onWindowResize, false);
            
            document.getElementById('instructions-header').addEventListener('click', (event) => {
                event.stopPropagation();
                document.getElementById('instructions-body').classList.toggle('collapsed');
                document.getElementById('instructions-toggle').innerHTML = document.getElementById('instructions-body').classList.contains('collapsed') ? '[+]' : '[-]';
            });
            
            document.getElementById('scoring-guide-header').addEventListener('click', (event) => {
                event.stopPropagation();
                document.getElementById('scoring-guide-body').classList.toggle('collapsed');
                document.getElementById('scoring-guide-toggle').innerHTML = document.getElementById('scoring-guide-body').classList.contains('collapsed') ? '[+]' : '[-]';
            });

            closeReportButton.addEventListener('click', () => { reportModalBackdrop.style.display = 'none'; });
            journalButton.addEventListener('click', showJournal);
            mapButton.addEventListener('click', showMap);
            closeMapButton.addEventListener('click', () => { mapModalBackdrop.style.display = 'none'; });
        }

        // --- TIME OF DAY ---
        function updateDayNightCycle(delta) {
            if (isSleeping) return; 
            
            gameTime += delta * 0.05;
            timeSinceLastDrink += delta * 0.05;
            if (gameTime > 24) gameTime -= 24;

            if (gameTime > 20 && !isSleeping) {
                startSleepSequence();
            }
            
            const timeOfDay = gameTime / 24;
            const skyColor = new THREE.Color();
            if (gameTime > 6 && gameTime < 19) {
                skyColor.setHSL(0.6, 0.8, 0.5 + Math.sin((timeOfDay - 0.25) * Math.PI * 2) * 0.2);
            } else {
                skyColor.setHSL(0.6, 0.8, 0.1);
            }
            scene.background = skyColor;
            scene.fog.color.copy(skyColor);
            ambientLight.intensity = Math.max(0.2, 0.3 + Math.sin((timeOfDay - 0.25) * Math.PI * 2) * 0.5);
            updateClockDisplay();
        }
        
        function updateClockDisplay() {
            const hours = Math.floor(gameTime);
            const minutes = Math.floor((gameTime % 1) * 60);
            clockValueElement.textContent = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
        }

        function getTimeOfDayString() {
            const hours = Math.floor(gameTime);
            if (hours >= 5 && hours < 8) return "at dawn";
            if (hours >= 8 && hours < 12) return "in the morning";
            if (hours >= 12 && hours < 17) return "in the afternoon";
            if (hours >= 17 && hours < 20) return "at dusk";
            return "at night";
        }


        // --- WORLD CREATION ---
        function getHeightAt(x, z) {
            const freq1 = 35, amp1 = 8;
            const freq2 = 18, amp2 = 4;
            let y = Math.sin(x / freq1) * Math.cos(z / freq1) * amp1;
            y += Math.sin(x / freq2) * Math.cos(z / freq2) * amp2;
            return y;
        }

        function createHills() {
            const segments = 100;
            const groundGeometry = new THREE.PlaneGeometry(worldSize, worldSize, segments, segments);
            const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3b853f, side: THREE.DoubleSide });
            const vertices = groundGeometry.attributes.position;
            for (let i = 0; i < vertices.count; i++) {
                const x = vertices.getX(i);
                const y_as_z = vertices.getY(i);
                vertices.setZ(i, getHeightAt(x, y_as_z));
            }
            groundGeometry.computeVertexNormals();
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);
        }
        
        function createWater() {
            const numPonds = THREE.MathUtils.randInt(3, 5);
            const waterMaterial = new THREE.MeshBasicMaterial({color: 0x336699, transparent: true, opacity: 0.7});

            for (let i = 0; i < numPonds; i++) {
                let bestPos = null;
                let lowestHeight = Infinity;
                for (let j = 0; j < 10; j++) {
                    const x = (Math.random() - 0.5) * (worldSize * 0.8);
                    const z = (Math.random() - 0.5) * (worldSize * 0.8);
                    const y = getHeightAt(x, z);
                    if (y < lowestHeight) {
                        lowestHeight = y;
                        bestPos = { x, y, z };
                    }
                }

                if (bestPos && lowestHeight < 0) {
                    const waterLevel = lowestHeight + Math.random() * 1.5;
                    const waterSize = THREE.MathUtils.randFloat(40, 100);
                    
                    const waterGeometry = new THREE.PlaneGeometry(waterSize, waterSize, 20, 20);
                    const vertices = waterGeometry.attributes.position;
                    const validVertices = [];
                    for (let k = 0; k < vertices.count; k++) {
                        const localX = vertices.getX(k);
                        const localZ = vertices.getY(k);
                        const worldX = bestPos.x + localX;
                        const worldZ = bestPos.z + localZ;
                        if (getHeightAt(worldX, worldZ) < waterLevel) {
                            validVertices.push(new THREE.Vector3(localX, localZ, 0));
                        }
                    }
                    
                    if (validVertices.length > 20) { 
                        const shape = new THREE.Shape(validVertices);
                        const geometry = new THREE.ShapeGeometry(shape);
                        const water = new THREE.Mesh(geometry, waterMaterial);
                        water.rotation.x = -Math.PI/2;
                        water.position.set(bestPos.x, waterLevel + 0.1, bestPos.z);
                        scene.add(water);
                        waterBodies.push(water);
                    }
                }
            }
        }

        function findDrinkingSpots() {
            waterBodies.forEach(water => {
                const bounds = new THREE.Box3().setFromObject(water);
                for (let i = 0; i < 20; i++) {
                    const x = THREE.MathUtils.randFloat(bounds.min.x, bounds.max.x);
                    const z = THREE.MathUtils.randFloat(bounds.min.z, bounds.max.z);
                    const y = getHeightAt(x,z);
                    if (y < water.position.y + 0.2 && y > water.position.y - 1) {
                         drinkingSpots.push(new THREE.Vector3(x, y + 0.8, z));
                    }
                }
            });
        }
        
        function createDeer() {
            deer = new THREE.Group();
            deer.isFallen = false; 
            const mainBodyMaterial = new THREE.MeshLambertMaterial({ color: 0x8b5a2b });
            const underbellyMaterial = new THREE.MeshLambertMaterial({ color: 0xC4A484 });
            const antlerMaterial = new THREE.MeshLambertMaterial({ color: 0xdcdcdc });
            const tailMaterial = new THREE.MeshLambertMaterial({ color: 0xffffff });
            
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.5, 1.8, 8);
            const deerBody = new THREE.Mesh(bodyGeometry, mainBodyMaterial);
            deerBody.rotation.x = Math.PI / 2; 
            deerBody.castShadow = true;
            deerBody.name = "body";

            const vitalGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5); 
            const vitalMaterial = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0 });
            const vitals = new THREE.Mesh(vitalGeometry, vitalMaterial);
            vitals.position.set(0, 0.1, 0);
            vitals.name = "vitals";
            deerBody.add(vitals);
            
            neck = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 0.8, 8), mainBodyMaterial);
            neck.castShadow = true;
            neck.position.set(0, 0.7, 0.6);
            neck.rotation.x = -Math.PI / 4;

            const headGroup = new THREE.Group();
            headGroup.name = "head";
            headGroup.position.set(0, 0.5, 0.3);
            const headGeometry = new THREE.SphereGeometry(0.35, 8, 8);
            const deerHead = new THREE.Mesh(headGeometry, mainBodyMaterial);
            deerHead.position.y = 0.2;
            const snoutGeometry = new THREE.CylinderGeometry(0.1, 0.2, 0.4, 8);
            const snout = new THREE.Mesh(snoutGeometry, underbellyMaterial);
            snout.position.set(0, 0.1, 0.3);
            snout.rotation.x = Math.PI / 2.5;
            headGroup.add(deerHead, snout);
            neck.add(headGroup);

            function createAntler() {
                const antler = new THREE.Group();
                const mainBranch = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.6), antlerMaterial);
                mainBranch.rotation.z = Math.PI / 6;
                const fork1 = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.04, 0.4), antlerMaterial);
                fork1.position.set(0.1, 0.2, 0);
                fork1.rotation.z = -Math.PI / 4;
                mainBranch.add(fork1);
                antler.add(mainBranch);
                return antler;
            }
            const leftAntler = createAntler();
            leftAntler.position.set(0.2, 0.4, -0.1);
            leftAntler.rotation.y = -Math.PI / 4;
            leftAntler.rotation.z = Math.PI / 8;
            headGroup.add(leftAntler);
            const rightAntler = createAntler();
            rightAntler.position.set(-0.2, 0.4, -0.1);
            rightAntler.rotation.y = Math.PI / 4;
            rightAntler.rotation.z = -Math.PI / 8;
            headGroup.add(rightAntler);
            
            const legGeometry = new THREE.CylinderGeometry(0.08, 0.06, 1.0, 8);
            function createLeg(x, z) {
                const leg = new THREE.Mesh(legGeometry, mainBodyMaterial);
                leg.castShadow = true;
                leg.position.set(x, -0.5, z);
                return leg;
            }
            legs = [createLeg(0.25, 0.7), createLeg(-0.25, 0.7), createLeg(0.25, -0.7), createLeg(-0.25, -0.7)];
            
            const tailGeometry = new THREE.CylinderGeometry(0.1, 0.02, 0.3, 8);
            const tail = new THREE.Mesh(tailGeometry, tailMaterial);
            tail.position.set(0, 0.3, -0.9);
            tail.rotation.x = -Math.PI / 2;
            
            deer.add(deerBody, neck, ...legs, tail);
            deer.scale.set(1.2, 1.2, 1.2);
            scene.add(deer);
            respawnDeer();
        }

        function createTrees() {
             const treeCount = 800;
            const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x5d412d });
            const leavesMaterial = new THREE.MeshLambertMaterial({ color: 0x2a753e });
            const worldSize = 450;
            for(let i = 0; i < treeCount; i++) {
                const posX = (Math.random() - 0.5) * worldSize;
                const posZ = (Math.random() - 0.5) * worldSize;
                const posY = getHeightAt(posX, posZ);

                let isSubmerged = false;
                for(const water of waterBodies) {
                    if(posY < water.position.y) {
                        const bounds = new THREE.Box3().setFromObject(water);
                        if (posX > bounds.min.x && posX < bounds.max.x && posZ > bounds.min.z && posZ < bounds.max.z) {
                           isSubmerged = true;
                           break;
                        }
                    }
                }
                if (isSubmerged) continue;

                const tree = new THREE.Group();
                const trunkHeight = 4 + Math.random() * 2;
                const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, trunkHeight), trunkMaterial);
                const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(1.5 + Math.random()), leavesMaterial);
                trunk.castShadow = true;
                trunk.name = "tree_trunk";
                leaves.castShadow = true;
                leaves.name = "tree_leaves";
                trunk.position.y = trunkHeight / 2;
                leaves.position.y = trunkHeight + leaves.geometry.parameters.radius / 2 - 1;
                tree.add(trunk, leaves);
                
                tree.position.set(posX, posY, posZ);
                if(tree.position.distanceTo(player.position) < 25) continue; 
                scene.add(tree);
                trees.push(tree); 
            }
        }
        
        function respawnDeer() {
            if (deerState !== 'KILLED') {
                huntLog = null; 
            }
            deer.rotation.set(0, 0, 0); 
            deer.isFallen = false;
            const distance = 80 + Math.random() * 150;
            const angle = Math.random() * Math.PI * 2;
            const x = player.position.x + Math.sin(angle) * distance;
            const z = player.position.z + Math.cos(angle) * distance;
            const y = getHeightAt(x, z) + 0.8;
            deer.position.set(x, y, z);
            deer.lookAt(player.position.x, y, player.position.z);
            setDeerState('WANDERING');
            lastTrackPosition.copy(deer.position);
            timeSinceLastDrink = 0;
        }

        function setDeerState(newState) {
            deerState = newState;
            stateTimer = 0;
            if (newState === 'WANDERING') {
                const wanderAngle = Math.random() * Math.PI * 2;
                const wanderDistance = 10 + Math.random() * 20;
                wanderTarget.set(
                    deer.position.x + Math.sin(wanderAngle) * wanderDistance,
                    0,
                    deer.position.z + Math.cos(wanderAngle) * wanderDistance
                );
            }
            if (newState === 'THIRSTY') {
                let closestSpot = null;
                let minDistance = Infinity;
                drinkingSpots.forEach(spot => {
                    const distance = deer.position.distanceTo(spot);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestSpot = spot;
                    }
                });
                if(closestSpot) wanderTarget.copy(closestSpot);
                else setDeerState('WANDERING');
            }
            if (newState === 'KILLED' || newState === 'WOUNDED') {
                legs.forEach(leg => leg.rotation.x = 0);
            }
            if (newState === 'WOUNDED') {
                lastBloodDropPosition.copy(deer.position);
            }
        }

        function createTrack() {
            const trackMaterial = new THREE.MeshLambertMaterial({ color: 0x4b3621, transparent: true });
            const trackShape = new THREE.Shape();
            const r = 0.08;
            trackShape.moveTo(0, r);
            trackShape.absarc(0, 0, r, Math.PI / 2, -Math.PI / 2, true);
            trackShape.absarc(0, 0, r * 0.5, -Math.PI / 2, Math.PI / 2, false);
            trackShape.lineTo(0, r);
            const extrudeSettings = { depth: 0.02, bevelEnabled: false };
            const geometry = new THREE.ExtrudeGeometry(trackShape, extrudeSettings);
            const leftHalf = new THREE.Mesh(geometry, trackMaterial);
            leftHalf.position.x = -0.05;
            const rightHalf = new THREE.Mesh(geometry, trackMaterial);
            rightHalf.position.x = 0.05;
            const track = new THREE.Group();
            track.add(leftHalf);
            track.add(rightHalf);
            track.position.set(deer.position.x, deer.position.y - 0.78, deer.position.z);
            track.rotation.x = -Math.PI / 2; 
            track.rotation.z = deer.rotation.y;
            scene.add(track);
            tracks.push({ mesh: track, timestamp: clock.getElapsedTime() });
        }

        function updateTracks(delta) {
            const trackLifetime = 360; 
            tracks = tracks.filter(track => {
                const age = clock.getElapsedTime() - track.timestamp;
                if (age > trackLifetime) {
                    scene.remove(track.mesh);
                    track.mesh.traverse(child => {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) child.material.dispose();
                    });
                    return false;
                }
                track.mesh.traverse(child => {
                    if (child.material) child.material.opacity = 1.0 - (age / trackLifetime);
                });
                return true;
            });
        }
        
        function createBloodDrop() {
            const dropGeometry = new THREE.SphereGeometry(0.04, 6, 6);
            const dropMaterial = new THREE.MeshBasicMaterial({ color: 0xDC143C, transparent: true });
            const drop = new THREE.Mesh(dropGeometry, dropMaterial);
            drop.position.set(deer.position.x, deer.position.y - 0.7, deer.position.z);
            scene.add(drop);
            bloodDrops.push({ mesh: drop, timestamp: clock.getElapsedTime() });
        }

        function updateBloodDrops(delta) {
            const bloodLifetime = 480; 
            bloodDrops = bloodDrops.filter(drop => {
                const age = clock.getElapsedTime() - drop.timestamp;
                if (age > bloodLifetime) {
                    scene.remove(drop.mesh);
                    drop.mesh.geometry.dispose();
                    drop.mesh.material.dispose();
                    return false;
                }
                drop.mesh.material.opacity = 1.0 - (age / bloodLifetime);
                return true;
            });
        }

        function showMessage(text, duration = 2000) {
            messageElement.textContent = text;
            messageElement.style.opacity = 1;
            setTimeout(() => { messageElement.style.opacity = 0; }, duration);
        }

        function shoot() {
            if (deerState === 'KILLED') return;
            
            gunshot.triggerAttackRelease("C1", "0.5s");

            if (gameTime < 5.5 || gameTime > 19.5) {
                score -= 100;
                scoreValueElement.textContent = score;
                showMessage("Illegal Shot! -100 Points", 3000);
                if (deerState !== 'WOUNDED') setDeerState('FLEEING');
                return;
            }

            raycaster.setFromCamera({ x: 0, y: 0 }, camera);
            const intersects = raycaster.intersectObject(deer, true);

            if (intersects.length === 0) {
                score -= 20;
                scoreValueElement.textContent = score;
                showMessage("Missed! -20 Points", 2000);
                if (deerState !== 'WOUNDED') setDeerState('FLEEING');
                return;
            }

            let hitObject = intersects[0].object;
            let hitName = hitObject.name;
            while (!hitName && hitObject.parent) {
                hitObject = hitObject.parent;
                hitName = hitObject.name;
            }
            const distance = player.position.distanceTo(deer.position);
            const wasMoving = deerState === 'FLEEING' || deerState === 'WOUNDED' || deerState === 'WANDERING';

            if (wasMoving) {
                score -= 50;
                scoreValueElement.textContent = score;
                showMessage("Hit moving target! -50 Points", 2000);
            }
            
            if (!huntLog) { 
                huntLog = {
                    initialSightingDistance: Math.round(distance * 1.09361),
                    firstShotResult: '',
                    distanceTrailed: 0,
                    recoveryShotDistance: null
                };
            }

            if (hitName === 'vitals' || hitName === 'head') {
                let shotScore;
                let shotMessage;
                let baseScore;

                if (deerState === 'WOUNDED') {
                    baseScore = 20; 
                    shotMessage = "Recovery Shot";
                    huntLog.recoveryShotDistance = Math.round(distance * 1.09361);
                } else {
                    baseScore = (hitName === 'vitals') ? 100 : 25;
                    shotMessage = (hitName === 'vitals') ? "Perfect Shot!" : "Headshot!";
                    huntLog.firstShotResult = shotMessage;
                }
                
                const maxPenaltyDistance = 250;
                const distanceFactor = Math.min(distance, maxPenaltyDistance) / maxPenaltyDistance;
                const penalty = distanceFactor * (baseScore * 0.75);
                shotScore = Math.round(baseScore - penalty);

                if (distance < 100) {
                    shotScore += (100 - Math.round(distance * 1.09361));
                }

                killInfo = { 
                    score: shotScore, 
                    message: shotMessage, 
                    wasMoving: wasMoving,
                    shotCount: (deerState === 'WOUNDED') ? 2 : 1,
                    distance: Math.round(distance * 1.09361)
                };
                setDeerState('KILLED');

            } else if (hitName === 'body') {
                if (deerState !== 'WOUNDED') {
                    score -= 25;
                    scoreValueElement.textContent = score;
                    setDeerState('WOUNDED');
                    huntLog.firstShotResult = 'Wounded';
                    showMessage("Wounded! -25 Points", 3000);
                }
            } else {
                if (deerState !== 'WOUNDED') setDeerState('FLEEING');
            }
        }

        function tagDeer() {
            if (!canTag || !killInfo) return;
            const shotScore = killInfo.score;
            const tagBonus = 25;
            const totalPoints = shotScore + tagBonus;
            score += totalPoints;
            scoreValueElement.textContent = score;
            
            const shotScoreStr = shotScore >= 0 ? `+${shotScore}` : shotScore;
            const finalMessage = `${killInfo.message} (${shotScoreStr}) | Tag Bonus: +${tagBonus}`;
            showMessage(finalMessage, 4000);
            
            dailyKillInfo = { ...huntLog, ...killInfo };
            huntLog = null; 
            
            killInfo = null;
            canTag = false;
            interactionPromptElement.style.display = 'none';
            respawnDeer();
        }

        async function handleEndOfDay() {
            const distanceInMiles = (distanceTraveled * 0.000621371).toFixed(2);
            let prompt;

            if (dailyKillInfo) {
                 prompt = `You are a seasoned hunter writing in your journal. Write a short, narrative paragraph (around 100-120 words) describing your day. Today you traveled ${distanceInMiles} miles and had a successful hunt. The tone should be respectful and reflective. Incorporate these details naturally:\n- Initial Sighting Distance: ${dailyKillInfo.initialSightingDistance} yards\n- First Shot: ${dailyKillInfo.firstShotResult}\n- Distance Trailed after first shot: ${Math.round(dailyKillInfo.distanceTrailed * 1.09361)} yards\n- Final Shot Type: ${dailyKillInfo.message}\n- Final Shot Distance: ${dailyKillInfo.recoveryShotDistance || dailyKillInfo.initialSightingDistance} yards.\n\nCombine these elements into a single journal entry about the day.`;
            } else if (huntLog) {
                 prompt = `You are a seasoned hunter writing in your journal. Write a short, narrative paragraph (around 80-100 words) describing your day. Today you traveled ${distanceInMiles} miles and had an unsuccessful hunt. You wounded a deer but failed to recover it after tracking it for ${Math.round(huntLog.distanceTrailed * 1.09361)} yards. The tone should be reflective and disappointed.`;
            } else {
                 prompt = `You are a seasoned hunter writing in your journal. Write a short, narrative paragraph (around 80-100 words) describing your day. Today you traveled ${distanceInMiles} miles but had an unsuccessful hunt and did not harvest a deer. The tone should be reflective, perhaps mentioning what you saw or the challenge of the hunt.`;
            }

            try {
                let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory };
                const apiKey = ""; 
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates[0]?.content?.parts[0]?.text) {
                    const text = result.candidates[0].content.parts[0].text;
                    journalEntries.unshift({title: `Day ${journalEntries.length + 1}`, content: text});
                    if (journalEntries.length > 5) journalEntries.pop(); 
                } else {
                   journalEntries.unshift({title: `Day ${journalEntries.length + 1}`, content: "The quiet of the woods was its own reward."});
                   // console.error("Gemini API Error:", result); // Logging disabled
                }
            } catch (error) {
                journalEntries.unshift({title: `Day ${journalEntries.length + 1}`, content: "The quiet of the woods was its own reward."});
                // console.error("Fetch Error:", error); // Logging disabled
            }
            
            showMessage("A new day has dawned. Check your journal.", 5000);
            distanceTraveled = 0;
            dailyKillInfo = null;
            huntLog = null;
        }
        
        function showJournal() {
            reportModalBackdrop.style.display = 'flex';
            reportTitle.textContent = "Hunter's Journal";
            if(journalEntries.length > 0) {
                reportContent.innerHTML = journalEntries.map(entry => `<h3>${entry.title}</h3><p>${entry.content}</p>`).join('<hr>');
            } else {
                reportContent.textContent = "Your journal is empty. A successful hunt will add an entry at the end of the day.";
            }
        }
        
        function startSleepSequence() {
            isSleeping = true;
            sleepOverlay.style.display = 'flex';
            let countdown = 30;
            sleepTimerElement.textContent = countdown;
            
            const sleepInterval = setInterval(() => {
                countdown--;
                sleepTimerElement.textContent = countdown;
                if (countdown <= 0) {
                    clearInterval(sleepInterval);
                }
            }, 1000);

            setTimeout(() => {
                sleepOverlay.style.opacity = 1;
                setTimeout(async () => {
                    await handleEndOfDay();
                    gameTime = 4.5; 
                    sleepOverlay.style.opacity = 0;
                    setTimeout(() => {
                        sleepOverlay.style.display = 'none';
                        isSleeping = false;
                    }, 2000);
                }, 30000); 
            }, 100);
        }


        // --- INPUT HANDLERS ---
        function onMouseDown(event) {
            if (event.target.closest('.hud') || event.target.closest('.modal-backdrop')) {
                return;
            }
            switch(event.button) {
                case 0:
                    if (document.pointerLockElement !== document.body) {
                        document.body.requestPointerLock();
                    } else {
                        shoot();
                    }
                    break;
                case 2:
                     if (document.pointerLockElement === document.body) {
                        toggleScope(true);
                    }
                    break;
            }
        }

        function onMouseUp(event) {
            if(event.button === 2) { 
                if (document.pointerLockElement === document.body) {
                    toggleScope(false); 
                }
            }
        }

        function toggleScope(active) {
            isScoped = active;
            if (isScoped) {
                camera.fov = 15;
                mouseSensitivity = 0.0005;
                scopeOverlayElement.style.display = 'block';
                crosshairElement.style.display = 'none';
            } else {
                camera.fov = 75;
                mouseSensitivity = 0.002;
                scopeOverlayElement.style.display = 'none';
                crosshairElement.style.display = 'block';
            }
            camera.updateProjectionMatrix();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = true; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
                case 'KeyS': case 'ArrowDown': moveBackward = true; break;
                case 'KeyD': case 'ArrowRight': moveRight = true; break;
                case 'KeyE': if(canTag) tagDeer(); break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': case 'ArrowUp': moveForward = false; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
                case 'KeyS': case 'ArrowDown': moveBackward = false; break;
                case 'KeyD': case 'ArrowRight': moveRight = false; break;
            }
        }

        function onMouseMove(event) {
            if (document.pointerLockElement === document.body) {
                player.rotation.y -= event.movementX * mouseSensitivity;
                camera.rotation.x -= event.movementY * mouseSensitivity;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
            }
        }
        
        // --- ANIMATION LOOP ---
        function updatePlayer(delta) {
            let moveSpeed = (isScoped ? 2.0 : 4.0) * delta; 
            const velocity = new THREE.Vector3();
            if (moveForward) velocity.z -= 1;
            if (moveBackward) velocity.z += 1;
            if (moveLeft) velocity.x -= 1;
            if (moveRight) velocity.x += 1;
            if (velocity.length() > 0) {
                velocity.normalize();
                player.translateX(velocity.x * moveSpeed);
                player.translateZ(velocity.z * moveSpeed);
                player.position.y = getHeightAt(player.position.x, player.position.z) + 1.7;

                const distanceMoved = player.position.distanceTo(lastPlayerPosition);
                distanceTraveled += distanceMoved;
                if (huntLog) {
                    huntLog.distanceTrailed += distanceMoved;
                }
                lastPlayerPosition.copy(player.position);
            }
        }
        
        function updateDeerAI(delta) {
            stateTimer += delta;
            if (deerState === 'KILLED') {
                if (!deer.isFallen) {
                    deer.rotation.z = THREE.MathUtils.lerp(deer.rotation.z, -Math.PI / 2, 0.05);
                    if (Math.abs(deer.rotation.z - (-Math.PI / 2)) < 0.01) {
                        deer.isFallen = true;
                    }
                }
                return;
            }

            if (timeSinceLastDrink > 18 && deerState === 'WANDERING') {
                setDeerState('THIRSTY');
            }

            const distToPlayer = deer.position.distanceTo(player.position);
            if (deerState !== 'FLEEING' && deerState !== 'WOUNDED' && deerState !== 'THIRSTY' && deerState !== 'DRINKING' && deerState !== 'GRAZING') {
                 let hasLineOfSight = true;
                if (distToPlayer < 120) {
                    const directionToPlayer = new THREE.Vector3().subVectors(player.position, deer.position).normalize();
                    raycaster.set(deer.position, directionToPlayer);
                    const intersects = raycaster.intersectObjects(trees, true); 
                    if (intersects.length > 0 && intersects[0].distance < distToPlayer) {
                        hasLineOfSight = false;
                    }
                }
                if (hasLineOfSight) {
                    if (distToPlayer < 60) setDeerState('FLEEING');
                    else if (distToPlayer < 80) setDeerState('ALERT');
                    else if (deerState === 'ALERT') setDeerState('WANDERING');
                } else if (!hasLineOfSight && deerState === 'ALERT') {
                    setDeerState('WANDERING');
                }
            }

            let speed = 0;
            let legAnimationSpeed = 0;
            switch(deerState) {
                case 'WANDERING':
                    if (Math.random() < 0.001) { setDeerState('GRAZING'); break; }
                case 'THIRSTY':
                    speed = (deerState === 'THIRSTY' ? 2.5 : 1.2) * delta; 
                    legAnimationSpeed = 12;
                    if (deer.position.distanceTo(wanderTarget) < 5.0) {
                        if (deerState === 'THIRSTY') {
                            setDeerState('DRINKING');
                        } else {
                            setDeerState('WANDERING');
                        }
                    }
                    deer.lookAt(new THREE.Vector3(wanderTarget.x, deer.position.y, wanderTarget.z));
                    deer.translateZ(speed);
                    break;
                case 'GRAZING':
                    neck.rotation.x = THREE.MathUtils.lerp(neck.rotation.x, Math.PI / 2.5, 0.1);
                    if (stateTimer > 5) { 
                        setDeerState('WANDERING');
                    }
                    break;
                case 'DRINKING':
                    neck.rotation.x = THREE.MathUtils.lerp(neck.rotation.x, Math.PI / 2, 0.1);
                    if (stateTimer > 10) { 
                        timeSinceLastDrink = 0;
                        setDeerState('WANDERING');
                    }
                    break;
                case 'ALERT':
                    neck.rotation.x = THREE.MathUtils.lerp(neck.rotation.x, Math.PI / 4, 0.1);
                    deer.lookAt(player.position.x, deer.position.y, player.position.z);
                    break;
                case 'FLEEING':
                case 'WOUNDED':
                    speed = (deerState === 'FLEEING' ? 9.0 : 4.5) * delta; 
                    legAnimationSpeed = (deerState === 'FLEEING' ? 35 : 20);
                    const fleeTarget = new THREE.Vector3().subVectors(deer.position, player.position).normalize();
                    deer.lookAt(new THREE.Vector3().addVectors(deer.position, fleeTarget));
                    deer.translateZ(speed);
                    if(stateTimer > 12) setDeerState('WANDERING');
                    break;
            }

            if (deerState !== 'GRAZING' && deerState !== 'DRINKING') {
                 neck.rotation.x = THREE.MathUtils.lerp(neck.rotation.x, Math.PI / 4, 0.1);
            }

            const boundary = worldSize / 2 - 20;
            if (Math.abs(deer.position.x) > boundary || Math.abs(deer.position.z) > boundary) {
                const center = new THREE.Vector3(0, deer.position.y, 0);
                deer.lookAt(center);
                if(deerState !== 'FLEEING' && deerState !== 'WOUNDED') {
                     setDeerState('WANDERING');
                     wanderTarget.set(0,0,0);
                }
            }

            deer.position.y = getHeightAt(deer.position.x, deer.position.z) + 0.8;
            if(speed > 0) {
                if (deer.position.distanceTo(lastTrackPosition) > 2.0) {
                    createTrack();
                    lastTrackPosition.copy(deer.position);
                }
                if (deerState === 'WOUNDED' && deer.position.distanceTo(lastBloodDropPosition) > 1.5) {
                    createBloodDrop();
                    lastBloodDropPosition.copy(deer.position);
                }
            }
            if (speed > 0) {
                const t = clock.getElapsedTime() * legAnimationSpeed;
                legs.forEach((leg, i) => leg.rotation.x = Math.sin(t + (i % 2 === 0 ? 0 : Math.PI)) * 0.5);
            } else {
                legs.forEach(leg => leg.rotation.x = 0);
            }
        }

        function updateInteraction() {
            if (deerState === 'KILLED' && deer.isFallen) {
                if (player.position.distanceTo(deer.position) < 4) {
                    interactionPromptElement.textContent = 'Press [E] to Tag Deer';
                    interactionPromptElement.style.display = 'block';
                    canTag = true;
                } else {
                    interactionPromptElement.style.display = 'none';
                    canTag = false;
                }
            } else {
                 interactionPromptElement.style.display = 'none';
                 canTag = false;
            }
        }
        
        function updateCompass() {
            let angle = player.rotation.y * (180 / Math.PI);
            angle = (angle % 360 + 360) % 360;
            const directions = ['S', 'SW', 'W', 'NW', 'N', 'NE', 'E', 'SE'];
            const index = Math.round(angle / 45) % 8;
            compassValueElement.textContent = directions[index];
        }

        // --- MAP FUNCTIONS ---
        function initMap() {
            mapRenderer = new THREE.WebGLRenderer({ antialias: true });
            mapRenderer.setSize(512, 512);
        }
        
        function showMap() {
            mapModalBackdrop.style.display = 'flex';
            
            const tempScene = new THREE.Scene();
            tempScene.background = new THREE.Color(0x1a472a);
            
            const tempCamera = new THREE.OrthographicCamera(-worldSize / 2, worldSize / 2, worldSize / 2, -worldSize / 2, 1, 2000);
            tempCamera.position.y = 500;
            tempCamera.lookAt(tempScene.position);
            
            const mapAmbient = new THREE.AmbientLight(0xffffff, 0.7);
            tempScene.add(mapAmbient);
            const mapDirectional = new THREE.DirectionalLight(0xffffff, 0.5);
            mapDirectional.position.set(100, 300, 200);
            tempScene.add(mapDirectional);
            
            tempScene.add(ground.clone());
            waterBodies.forEach(water => tempScene.add(water.clone()));
            trees.forEach(tree => {
                const mapTree = tree.clone();
                mapTree.traverse(child => {
                    if (child.isMesh) {
                         child.material = new THREE.MeshBasicMaterial({color: 0x14501e});
                    }
                });
                tempScene.add(mapTree);
            });

            mapRenderer.render(tempScene, tempCamera);
            
            const mapContext = mapCanvas.getContext('2d');
            mapContext.clearRect(0, 0, mapCanvas.width, mapCanvas.height);
            mapContext.drawImage(mapRenderer.domElement, 0, 0);

            const playerX = (player.position.x / worldSize) * 512 + 256;
            const playerZ = (-player.position.z / worldSize) * 512 + 256;

            mapContext.fillStyle = 'red';
            mapContext.strokeStyle = 'white';
            mapContext.lineWidth = 2;

            mapContext.beginPath();
            mapContext.arc(playerX, playerZ, 6, 0, Math.PI * 2); 
            mapContext.fill();
            mapContext.stroke();
        }

        
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            updateDayNightCycle(delta);
            updatePlayer(delta);
            updateDeerAI(delta);
            updateTracks(delta);
            updateBloodDrops(delta);
            updateInteraction();
            updateCompass();
            renderer.render(scene, camera);
        }

        init();
        animate();
    -->
</body>
</html>
